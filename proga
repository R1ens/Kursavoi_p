// ------------------------------------------------------------
// KP_AGM_v7.cpp
// Чистая версия программы с реализованными пунктами 1–7 (как в текущем варианте).
// Добавлена реализация пункта 8: расчет параметров пограничного слоя (табл. 8).
// ------------------------------------------------------------

#define _USE_MATH_DEFINES //для использования констант как пи
#include <iostream>
#include <cmath> //для подключения _USE_MATH_DEFINES
#include <string> 
#include <iomanip>
using namespace std;

void atmosphere(double h, double& H, double& g, double& d, double& p, double& T, double& a, double& r, double& R, double& g0, double& T0, double& H0, double& p0) {
    double b;
    R = 287.053;
    r = 6356767;
    g0 = 9.80665;

    H = (r * h) / (r + h);
    g = g0 * pow((r / (r + h)), 2);

    if ((h >= -1999) && (h < 0)) {
        b = -0.0065;
        T0 = 301.15;
        H0 = -2000;
        p0 = 127774;
    }
    else if ((h >= 0) && (h < 11019)) {
        b = -0.0065;
        T0 = 288.15;
        H0 = 0;
        p0 = 101325;
    }
    else if ((h >= 11019) && (h < 20063)) {
        b = 0;
        T0 = 216.65;
        H0 = 11000;
        p0 = 22632;
    }
    else if ((h >= 20063) && (h < 32162)) {
        b = 0.0010;
        T0 = 216.65;
        H0 = 20000;
        p0 = 5474.87;
    }
    else if ((h >= 32162) && (h < 47350)) {
        b = 0.0028;
        T0 = 228.65;
        H0 = 32000;
        p0 = 868.014;
    }
    else if ((h >= 47350) && (h < 51412)) {
        b = 0;
        T0 = 270.65;
        H0 = 47000;
        p0 = 110.906;
    }
    else if ((h >= 51412) && (h < 71802)) {
        b = -0.0028;
        T0 = 270.65;
        H0 = 51000;
        p0 = 66.9384;
    }
    else if ((h >= 71802) && (h < 86152)) {
        b = -0.0020;
        T0 = 214.65;
        H0 = 71000;
        p0 = 3.95639;
    }
    else if ((h >= 86152) && (h < 95411)) {
        b = 0.0000;
        T0 = 186.65;
        H0 = 85000;
        p0 = 0.445710;
    }

    T = T0 + b * (H - H0);

    if (b == 0) {
        p = pow(10, (log10(p0) + ((-0.434294 / (R * T)) * g0 * (H - H0))));

    }
    else p = pow(10, (log10(p0) - ((g0 * log10((T0 + b * (H - H0)) / T0)) / (b * R))));

    d = p / (R * T);
    a = 20.046796 * sqrt(T);

    return;
}

double FindThetta(double beta, double k, double M) 
{
    double a1 = tan(beta) * ((k - 1) / 2 * M * M + 1);
    double b1 = 1 - M * M;
    double c1 = tan(beta) * (1 + (k + 1) / 2 * M * M);
    int d1 = 1;

    double a = b1 / a1;
    double b = c1 / a1;
    double c = d1 / a1;

    double p = -a * a / 3 + b;
    double q = 2 * pow((a / 3), 3) - (a * b) / 3 + c;
    double Q = pow(p / 3, 3) + pow(q / 2, 2);
    double x, alfa;

    if (Q > 0) {
        //cout << "\nРешение для присоединенного скачка отсутствует";
        return 0;
    }
    else if (Q < 0) {
        alfa = acos(q / (2 * pow(-p / 3, 1.5)));
        x = 2 * pow(-p / 3, 0.5) * cos(alfa / 3 + M_PI / 3) - a / 3;
        //cout << "\nOno" << "\n" << alfa << "\n" << q<<"\n"<< p;
        return atan(x);
    }
    else if (Q == 0) {
        x = pow(-q / 2, 1 / 3) - a / 3;
        
        return atan(x);
    }
    return 0;
}

double FindW(double k, double M) {
    double w = sqrt((k + 1) / (k - 1)) * atan(sqrt(((k - 1) / (k + 1)) * ((M * M) - 1))) - atan(sqrt((M * M) - 1));
    return w;
}

void ParamTorm(double& p0, double& ro0, double& T0, double p_8, double ro_8, double T_8, double k, double M) {
    p0 = p_8 * pow((1 + (k - 1) / 2 * M * M), k / (k - 1));
    ro0 = ro_8 * pow((1 + (k - 1) / 2 * M * M), (1 / (k - 1)));
    T0 = T_8 * (1 + (k - 1) / 2 * M * M);
}

void Gr12(double& M, double& p, double& ro, double& T, double& v, /*double& p0,*/ double& mu, double p_8, double k, double M_8, double thetta, double ro_8, double T_8, double v_8, double beta) {
    M = sqrt((((2 + (k - 1) * M_8 * M_8) / (2 * k * M_8 * M_8 * pow(sin(thetta), 2) - (k - 1))) + ((2 * M_8 * M_8 * pow(cos(thetta), 2)) / (2 + (k - 1) * M_8 * M_8 * pow(sin(thetta), 2)))));
    p = p_8 * (2 * k / (k + 1) * M_8 * M_8 * pow(sin(thetta), 2) - (k - 1) / (k + 1));
    ro = ro_8 * ((0.5 * (k + 1) * M_8 * M_8 * pow(sin(thetta), 2)) / (1 + 0.5 * (k - 1) * M_8 * M_8 * pow(sin(thetta), 2)));
    T = T_8 * p / p_8 * ro_8 / ro;
    v = v_8 * cos(thetta) / cos(thetta - beta);
    //p0 = p * pow((1 + (k - 1) / 2 * M * M), (k / (k - 1)));
    mu = asin(1 / M);
}

void Gr34(double& M, double& w_0,double& p, double& ro, double& T, double& a, double& v, double& mu, double w_1, double k, double p0, double ro0, double T0) {
    double w_2;
    do {
        M = M + 0.0001;
        w_2 = FindW(k, M);
    } 
    while (fabs(w_2 - w_1) > 0.00001);
    p = p0 * pow((1 + ((k - 1) / 2) * M * M), -k / (k - 1));
    ro = ro0 * pow((1 + ((k - 1) / 2) * M * M), -1 / (k - 1));
    T = T0 * pow((1 + ((k - 1) / 2) * M * M), -1);
    a = sqrt(k * p / ro);
    v= M * a;
    mu = asin(1 / M);
}

void FindCpMLbd(double T, double& cp, double& mu, double& lbd) {
    double cp_const, mu_const, lbd_const, fi, n, dzetta, T1, T2;
    cp_const = 1004.7; //удельная теплоемкость воздуха 
    mu_const = 1.79 * pow(10, -5); //динамическая вязкость 
    lbd_const = 0.0232; //теплопроводность воздуха 
    fi = 0.1;
    n = 0.76;
    dzetta = 0.85;
    T1 = 288.15;
    T2 = 261;
    cp = cp_const * pow(T / T1, fi);
    mu = mu_const * pow(T / T1, n);
    lbd = lbd_const * pow(T / T2, dzetta);
}

void FindDelta(double M_1, double M_2, double alpha, double beta_k, double k, double p_1, double p_2, double& p_5, double& p_6, double& teta_c5, double& teta_c6, double& d) {
    double beta;
    double delta = alpha;
    do
    {
        beta = beta_k + delta;
        teta_c5 = FindThetta(beta, k, M_1);
        beta = beta_k - delta;
        teta_c6 = FindThetta(beta, k, M_2);
        p_5 = p_1 * (2 * k / (k + 1) * M_1 * M_1 * sin(teta_c5) * sin(teta_c5) - (k - 1) / (k + 1));
        p_6 = p_2 * (2 * k / (k + 1) * M_2 * M_2 * sin(teta_c6) * sin(teta_c6) - (k - 1) / (k + 1));
        d = delta;
        if (p_6 < p_5)
            delta = delta - delta / pow(10, 6);
        else
            delta = delta + delta / pow(10, 6);
    } while (abs(p_5 - p_6) > 1);
    cout << "\np_5 = " << p_5 << "\np_6 = " << p_6 << endl;

}

// Коэфициент давления
void Koefp(double& p_, double p, double p_8, double q) {
    p_ = (p - p_8) / q;
}

// Функция температуры восстановления и определяющей температуры, ламинарный/турбулентный поток
void Tr_T_opr(double& Tr, double& T_opr, double lt, double T, double M, double k, double T_st) {
    double Trab, st, r, cp, mu, lbd, Prndl;

    T_opr = (T + T_st) / 2;
    Trab = T_opr;

    FindCpMLbd(Trab, cp, mu, lbd);
    Prndl = cp * mu / lbd;

    if (lt == 1) {
        st = 1.0 / 2.0;
    }
    else st = 1.0 / 3.0;

    r = pow(Prndl, st);
    Tr = T * (1 + r * (k - 1) * 0.5 * M * M);
    T_opr = 0.5 * (T_st + T) + 0.22 * (Tr - T);

    if (abs((T_opr - Trab) / T_opr) > 0.001) {
        Trab = T_opr;
        FindCpMLbd(Trab, cp, mu, lbd);
        Prndl = cp * mu / lbd; 
        r = pow(Prndl, st);
        Tr = T * (1 + r * (k - 1) * 0.5 * M * M);
        T_opr = 0.5 * (T_st + T) + 0.22 * (Tr - T);
    }
}

// Функция для определения критического числа Рейнольдса
void Rekr(double& Re, double T_st, double Tr, double M, double Re_kr) {
    double T_st_otn, x, y;
    T_st_otn = T_st / Tr;
    x = (T_st_otn - 1) / pow(M, 2);
    y = 1 - 16 * x - 412.5 * pow(x, 2) - 35000 * pow(x, 3) - 375000 * pow(x, 4);
    Re = Re_kr * y;
}

// ===================== Пункт 8: параметры пограничного слоя (табл. 8) =====================

// Ламинарный несжимаемый ПС (плоская пластина)
void LamNes(double& Re, double& dlt, double& tau, double& cfx, double& cf, double& dlt_star,
            double& dlt_star_sqr, double V, double rho, double x, double mu) {
    Re = (V * rho * x) / mu;
    dlt = (4.64 * x) / sqrt(Re);
    tau = (0.323 * rho * V * V) / sqrt(Re);
    cfx = 0.646 / sqrt(Re);
    cf  = 1.292 / sqrt(Re);
    dlt_star     = 1.74 * x / sqrt(Re);
    dlt_star_sqr = 0.646 * x / sqrt(Re);
}

// Ламинарный сжимаемый ПС (поправка по определяющей температуре)
void LamS(double& DLT, double& Tau, double& CFX, double& Cf, double& Dlt_star,
          double& Dlt_star_sqr, double dlt, double tau, double cfx, double cf,
          double dlt_star, double dlt_star_sqr, double Tstarl, double T, double ndin) {

    DLT = dlt * pow((Tstarl / T), (0.5 * (ndin + 1)));
    Tau = tau * pow((Tstarl / T), (0.5 * (ndin - 1)));
    CFX = cfx * pow((Tstarl / T), (0.5 * (ndin - 1)));
    Cf  = cf  * pow((Tstarl / T), (0.5 * (ndin - 1)));
    Dlt_star     = dlt_star     * DLT / dlt;
    Dlt_star_sqr = dlt_star_sqr * CFX / cfx;
}

// Турбулентный несжимаемый ПС
void TurNes(double& Re, double& dlt, double& tau, double& cfx, double& cf, double& dlt_star,
            double& dlt_star_sqr, double V, double rho, double x, double mu) {
    Re = (V * rho * x) / mu;
    dlt = (0.37 * x) / pow(Re, 0.2);
    tau = (0.0289 * rho * V * V) / pow(Re, 0.2);
    cfx = 0.0578 / pow(Re, 0.2);
    cf  = 0.074  / pow(Re, 0.2);

    const double k_ = 7.0;
    dlt_star     = dlt / (k_ + 1.0);
    dlt_star_sqr = (dlt * k_) / ((k_ + 1.0) * (k_ + 2.0));
}

// Турбулентный несжимаемый ПС (для точек с фиктивной длиной deltaX: нужны Cf0 на deltaX)
void TurNes8_9_17_18(double& Re, double& dlt, double& tau, double& cfx, double& cf, double& cf1,
                     double& dlt_star, double& dlt_star_sqr, double V, double rho, double x, double mu,
                     double deltaX, double& Re1) {

    Re  = (V * rho * x) / mu;
    Re1 = (V * rho * deltaX) / mu;

    dlt = (0.37 * x) / pow(Re, 0.2);
    tau = (0.0289 * rho * V * V) / pow(Re, 0.2);
    cfx = 0.0578 / pow(Re, 0.2);
    cf  = 0.074 / pow(Re, 0.2);
    cf1 = 0.074 / pow(Re1, 0.2);

    const double k_ = 7.0;
    dlt_star     = dlt / (k_ + 1.0);
    dlt_star_sqr = (dlt * k_) / ((k_ + 1.0) * (k_ + 2.0));
}

// Турбулентный сжимаемый ПС
void TurS(double& DLT, double& TAU, double& CfX, double& Cf, double& Dlt_star, double& Dlt_star_sqr,
          double dlt, double tau, double cfx, double cf, double dlt_star, double dlt_star_sqr,
          double Tstart, double T, double ndin) {

    DLT = dlt * pow((Tstart / T), (0.2 * (ndin + 1)));
    TAU = tau * pow((Tstart / T), (0.2 * (ndin - 4)));
    CfX = cfx * pow((Tstart / T), (0.2 * (ndin - 4)));
    Cf  = cf  * pow((Tstart / T), (0.2 * (ndin - 4)));
    Dlt_star     = dlt_star     * DLT / dlt;
    Dlt_star_sqr = dlt_star_sqr * CfX / cfx;
}

// Турбулентный сжимаемый ПС (для точек с фиктивной длиной deltaX: корректируем средний Cf по длине участка)
void TurS8_9_17_18(double& DLT, double& TAU, double& CfX, double& Cf_it, double& Dlt_star, double& Dlt_star_sqr,
                   double dlt, double tau, double cfx,
                   double cf, double cf1, double dlt_star, double dlt_star_sqr,
                   double Tstart, double T, double ndin, double deltaX, double xf) {

    DLT = dlt * pow((Tstart / T), (0.2 * (ndin + 1)));
    TAU = tau * pow((Tstart / T), (0.2 * (ndin - 4)));
    CfX = cfx * pow((Tstart / T), (0.2 * (ndin - 4)));

    const double Cf00 = cf1 * pow((Tstart / T), (0.2 * (ndin - 4))); // средний Cf на фиктивной длине deltaX
    const double Cf01 = cf  * pow((Tstart / T), (0.2 * (ndin - 4))); // средний Cf от 0 до xf

    // Средний Cf от 0 до (xf - deltaX) на рассматриваемой грани:
    Cf_it = Cf01 * xf / (xf - deltaX) - Cf00 * deltaX / (xf - deltaX);

    Dlt_star     = dlt_star     * DLT / dlt;
    Dlt_star_sqr = dlt_star_sqr * CfX / cfx;
}

// Аналитическое вычисление Δx из условия δл = δт (формула на стр. 15)
double DeltaX_from_deltaLam(double delta_l, double V, double rho, double mu, double Tstar_turb, double T_edge, double ndin) {
    // delta_l - уже "сжимаемая" толщина δл в критическом сечении
    const double A = pow((V * rho) / mu, 0.2);                          // (vρ/μ)^(1/5)
    const double B = 0.37 * pow((Tstar_turb / T_edge), 0.2 * (ndin + 1)); // 0.37*(T*_тпс/Tδ)^((n+1)/5)
    return pow(delta_l * A / B, 1.25); // степень 5/4
}

// Фиктивная длина xf0 для турбулентного слоя при заданной толщине δ0 в начале грани (стр. 18)
double Xf_from_deltaTurb(double delta0, double V, double rho, double mu, double Tstar_turb, double T_edge, double ndin) {
    const double K = 0.37 * pow(mu / (V * rho), 0.2) * pow((Tstar_turb / T_edge), 0.2 * (ndin + 1));
    // δ = K * xf^(4/5)  => xf = (δ/K)^(5/4)
    return pow(delta0 / K, 1.25);
}

struct BLRow {
    int face = 0;
    int point = 0;
    double x = 0.0;   // м (по грани)
    double xf = 0.0;  // м (для формул пластины)

    // несжимаемые
    double delta_ns = 0.0;
    double Re_ns = 0.0;
    double tau_ns = 0.0;
    double cfx_ns = 0.0;
    double cf_ns = 0.0;
    double delta_star_ns = 0.0;
    double delta_sqr_ns = 0.0;

    // сжимаемые
    double delta = 0.0;
    double tau = 0.0;
    double cfx = 0.0;
    double cf = 0.0;
    double delta_star = 0.0;
    double delta_sqr = 0.0;
};

static void PrintBLHeader() {
    cout << "\n\nТабл. 8. Параметры пограничного слоя по расчетным точкам на гранях\n";
    cout << left
         << setw(6)  << "Грань"
         << setw(6)  << "Тч"
         << setw(10) << "x"
         << setw(10) << "xf"
         << setw(10) << "d_ns"
         << setw(10) << "Re_ns"
         << setw(10) << "tau_ns"
         << setw(10) << "Cfx_ns"
         << setw(10) << "Cf_ns"
         << setw(10) << "d*_ns"
         << setw(10) << "d**_ns"
         << setw(10) << "d"
         << setw(10) << "tau"
         << setw(10) << "Cfx"
         << setw(10) << "Cf"
         << setw(10) << "d*"
         << setw(10) << "d**"
         << "\n";

    cout << "Примечание: d, d*, d** в таблице выводятся в 10^-3 м; Re — в 10^6; Cfx и Cf — в 10^-3.\n";
}

static void PrintBLRow(const BLRow& r) {
    auto dmm = [](double v) { return v * 1e3; };
    auto Re6 = [](double v) { return v / 1e6; };
    auto c1e3 = [](double v) { return v * 1e3; };

    cout << fixed << setprecision(3)
         << setw(6)  << r.face
         << setw(6)  << r.point
         << setw(10) << r.x
         << setw(10) << r.xf;

    cout << fixed << setprecision(3)
         << setw(10) << dmm(r.delta_ns)
         << setw(10) << Re6(r.Re_ns)
         << setw(10) << r.tau_ns
         << setw(10) << c1e3(r.cfx_ns)
         << setw(10) << c1e3(r.cf_ns)
         << setw(10) << dmm(r.delta_star_ns)
         << setw(10) << dmm(r.delta_sqr_ns)
         << setw(10) << dmm(r.delta)
         << setw(10) << r.tau
         << setw(10) << c1e3(r.cfx)
         << setw(10) << c1e3(r.cf)
         << setw(10) << dmm(r.delta_star)
         << setw(10) << dmm(r.delta_sqr)
         << "\n";
}



int main() {
    setlocale(LC_ALL, "RU");

    //ИД
    int N = 16; //вариант
    double c = 100; //мм, ширина профиля
    double b = 1200; //мм, длина профиля
    double h = (10 + 0.4 * N)*1000;//м, высота геометрическая (в условии это Н!!!)
    double M = 4.5 + 0.1 * N;//скорость полета М
    double alfa = 2 + 0.1 * N;//град, угол атаки
    cout << "ИД\nM = " << M << "\nalfa = " << alfa << endl;
    alfa = alfa * M_PI / 180;//перевод в радианы
    double T_ct = 370;//К, температура охлаждаемой стенки 
    double Re_kp = 5000000;//критическое число Рейнольдса 
    double k = 1.4; // Отношение удельных теплоемкостей воздуха??
    

    //Атмосфера ГОСТ 4401-81
    double H, g, ro_8, p_8, T_8, a_8, r, R, g0, T0_8, H0, p0_8;
    if ((h < -1999) || (h > 95411)) {
        cout << "Значение h должно входить в диапазон [-1999; 95411)" << endl;
        exit(0);
    }
    else
    {
        atmosphere(h, H, g, ro_8, p_8, T_8, a_8, r, R, g0, T0_8, H0, p0_8);
    }
    string otvet[7] = {
    "h = " + to_string(h),
    "H = " + to_string(H),
    "p = " + to_string(p_8),
    "d = " + to_string(ro_8),
    "g = " + to_string(g),
    "a = " + to_string(a_8),
    "T = " + to_string(T_8)
    };
    cout << "\nАтмосфера" << endl;
    for (int i = 0; i <= 6; i++)
        cout << otvet[i] << endl;

    //Расчет параметров потока по граням
    double beta = atan(c / b); //в рад
        //набегающий невозмущенный поток
    double v_8 = M * a_8;
    double p0, ro0, T0;
    ParamTorm(p0, ro0, T0, p_8, ro_8, T_8, k, M);
    cout << "\nПараметры набегающего потока :\nv_8 = " << v_8 << "\np0_8 = " << p0 << "\nro0 = " << ro0 << "\nT0 = " << T0;

    //Грань 1
    double beta_1 = beta - alfa; //рад
    double thetta_1 = FindThetta(beta_1, k, M);
    cout << "\n\nГрань 1\nthetta_1(grad) = " << thetta_1 / M_PI * 180;
    double M_1, p_1, ro_1, T_1, v_1, p0_1, mu_M_1;
    Gr12(M_1, p_1, ro_1, T_1, v_1, /*p0_1,*/ mu_M_1, p_8, k, M, thetta_1, ro_8, T_8, v_8, beta_1);
    cout << "\nM_1 = " << M_1 << "\np_1 = " << p_1 << "\nro_1 = " << ro_1 << "\nT_1 = " << T_1 << "\nv_1 = " << v_1 << "\n!mu_1 = " << mu_M_1 / M_PI * 180;
    double ro0_1, T0_1;
    ParamTorm(p0_1, ro0_1, T0_1, p_1, ro_1, T_1, k, M_1);
    cout << "\nПараметры торможения :\np0_1 = " << p0_1 << "\nro0_1 = " << ro0_1 << "\nT0_1 = " << T0_1;
    double w_1 = FindW(k, M_1);
    double cp_1, mu_1, lbd_1;
    FindCpMLbd(T_1, cp_1, mu_1, lbd_1);
    cout << "\ncp_1 = " << cp_1 << "\nmu_1 = " << mu_1 << "\nlbd_1 = " << lbd_1;

    //Грань 2
    double beta_2 = beta + alfa; //рад
    double thetta_2 = FindThetta(beta_2, k, M);
    cout << "\n\nГрань 2\nthetta_2(grad) = " << thetta_2 / M_PI * 180;
    double M_2, p_2, ro_2, T_2, v_2, p0_2, mu_M_2;
    Gr12(M_2, p_2, ro_2, T_2, v_2, /*p0_2,*/ mu_M_2, p_8, k, M, thetta_2, ro_8, T_8, v_8, beta_2);
    cout << "\nM_2 = " << M_2 << "\np_2 = " << p_2 << "\nro_2 = " << ro_2 << "\nT_2 = " << T_2 << "\nv_2 = " << v_2 << "\n!mu_2 = " << mu_M_2 / M_PI * 180;
    double ro0_2, T0_2;
    ParamTorm(p0_2, ro0_2, T0_2, p_2, ro_2, T_2, k, M_2);
    cout << "\nПараметры торможения :\np0_2 = " << p0_2 << "\nro0_2 = " << ro0_2 << "\nT0_2 = " << T0_2;
    double w_2 = FindW(k, M_2);
    double cp_2, mu_2, lbd_2;
    FindCpMLbd(T_2, cp_2, mu_2, lbd_2);
    cout << "\ncp_2 = " << cp_2 << "\nmu_2 = " << mu_2 << "\nlbd_2 = " << lbd_2;


    //Грань 3
    double w_3 = FindW(k, M_1) + beta * 2;
    cout << "\n\nГрань 3";
    double p_3, ro_3, T_3, a_3, v_3, mu_M_3;
    
    double p0_3 = p0_1;
    double ro0_3 = ro0_1;
    double T0_3 = T0_1;

    double M_3 = 1;
    Gr34(M_3, w_1, p_3, ro_3, T_3, a_3, v_3, mu_M_3, w_3, k, p0_3, ro0_3, T0_3);
    cout << "\nM_3 = " << M_3 << "\np_3 = " << p_3 << "\nro_3 = " << ro_3 << "\nT_3 = " << T_3 << "\nv_3 = " << v_3 << "\n!mu_3 = " << mu_M_3 / M_PI * 180;
    cout << "\nПараметры торможения :\np0_3 = " << p0_3 << "\nro0_3 = " << ro0_3 << "\nT0_3 = " << T0_3;
    double cp_3, mu_3, lbd_3;
    FindCpMLbd(T_3, cp_3, mu_3, lbd_3);
    cout << "\ncp_3 = " << cp_3 << "\nmu_3 = " << mu_3 << "\nlbd_3 = " << lbd_3;


    //Грань 4
    double w_4 = FindW(k, M_2) + beta * 2;
    cout << "\n\nГрань 4";
    double p_4, ro_4, T_4, a_4, v_4, mu_M_4;

    double p0_4 = p0_2;
    double ro0_4 = ro0_2;
    double T0_4 = T0_2;

    double M_4 = 1;
    Gr34(M_4, w_2, p_4, ro_4, T_4, a_4, v_4, mu_M_4, w_4, k, p0_4, ro0_4, T0_4);
    cout << "\nM_4 = " << M_4 << "\np_4 = " << p_4 << "\nro_4 = " << ro_4 << "\nT_4 = " << T_4 << "\nv_4 = " << v_4 << "\n!mu_4 = " << mu_M_4 / M_PI * 180;
    cout << "\nПараметры торможения :\np0_4 = " << p0_4 << "\nro0_4 = " << ro0_4 << "\nT0_4 = " << T0_4;
    double cp_4, mu_4, lbd_4;
    FindCpMLbd(T_4, cp_4, mu_4, lbd_4);
    cout << "\ncp_4 = " << cp_4 << "\nmu_4 = " << mu_4 << "\nlbd_4 = " << lbd_4;


        // 5 и 6 области
    cout << "\n\nГрани 5, 6";
    double p_5, p_6, teta_c5, teta_c6, M_5, ro_5, T_5, v_5, mu_M_5, delta_new, M_6, ro_6, T_6, v_6, mu_M_6, cp_5, cp_6, mu_5, mu_6, lbd_5, lbd_6;
    FindDelta(M_3, M_4, alfa, beta, k, p_3, p_4, p_5, p_6, teta_c5, teta_c6, delta_new);
    double beta_5 = beta + delta_new;
    double beta_6 = beta - delta_new;

    //Грань 5
    cout << "\n\nГрань 5";
    Gr12(M_5, p_5, ro_5, T_5, v_5, /*p0_2,*/ mu_M_5, p_3, k, M_3, teta_c5, ro_3, T_3, v_3, beta_5);
    cout << "\nM_5 = " << M_5 << "\np_5 = " << p_5 << "\nro_5 = " << ro_5 << "\nT_5 = " << T_5 << "\nv_5 = " << v_5 << "\n!mu_5 = " << mu_M_5 / M_PI * 180;
    double p0_5, ro0_5, T0_5;
    ParamTorm(p0_5, ro0_5, T0_5, p_5, ro_5, T_5, k, M_5);
    cout << "\nПараметры торможения :\np0_5 = " << p0_5 << "\nro0_5 = " << ro0_5 << "\nT0_5 = " << T0_5;
    FindCpMLbd(T_5, cp_5, mu_5, lbd_5);
    cout << "\ncp_5 = " << cp_5 << "\nmu_5 = " << mu_5 << "\nlbd_5 = " << lbd_5;

    //Грань 6
    cout << "\n\nГрань 6";
    Gr12(M_6, p_6, ro_6, T_6, v_6, /*p0_2,*/ mu_M_6, p_4, k, M_4, teta_c6, ro_4, T_4, v_4, beta_6);
    cout << "\nM_6 = " << M_6 << "\np_6 = " << p_6 << "\nro_6 = " << ro_6 << "\nT_6 = " << T_6 << "\nv_6 = " << v_6 << "\n!mu_6 = " << mu_M_6 / M_PI * 180;
    double p0_6, ro0_6, T0_6;
    ParamTorm(p0_6, ro0_6, T0_6, p_6, ro_6, T_6, k, M_6);
    cout << "\nПараметры торможения :\np0_6 = " << p0_6 << "\nro0_6 = " << ro0_6 << "\nT0_6 = " << T0_6;
    FindCpMLbd(T_6, cp_6, mu_6, lbd_6);
    cout << "\ncp_6 = " << cp_6 << "\nmu_6 = " << mu_6 << "\nlbd_6 = " << lbd_6;
    
    // Расчет АД коэфициентов
    // Скоростной напор
    double q_8 = (ro_8 * v_8 * v_8) / 2;
    // Коэфициенты давления
    double p_1_, p_2_, p_3_, p_4_;
    Koefp(p_1_, p_1, p_8, q_8);
    Koefp(p_2_, p_2, p_8, q_8);
    Koefp(p_3_, p_3, p_8, q_8);
    Koefp(p_4_, p_4, p_8, q_8);
    cout << "\n\nКоэфициенты давления :\np_1_ = " << p_1_ << "\np_2_ = " << p_2_ << "\np_3_ = " << p_3_ << "\np_4_ = " << p_4_;

    // Коэфициенты сил
    double C_x, C_y, C_xa, C_ya, m_z, Cd, K;
    C_x = (0.5 * c / b) * (p_1_ + p_2_ - p_3_ - p_4_);
    C_y = 0.5 * (p_2_ + p_4_ - p_1_ - p_3_);
    C_xa = C_x * cos(alfa) + C_y * sin(alfa);
    C_ya = -C_x * sin(alfa) + C_y * cos(alfa);
    m_z = (pow(c / b, 2) / 8) * (p_1_ - p_2_ - p_3_ + p_4_) + (1. / 8) * (p_1_ - p_2_ + 3 * p_3_ - 3 * p_4_);
    Cd = -m_z / C_y;
    K = C_ya / C_xa;
    cout << "\n\nКоэфициенты сил :\nC_x = " << C_x << "\nC_y = " << C_y << "\nC_xa = " << C_xa << "\nC_ya = " << C_ya << "\nm_z = " << m_z << "\nCd = " << Cd << "\nK = " << K;


    // Температура восстановления и определяющая температура на гранях
    double Trl_1, Toprl_1, Trl_2, Toprl_2, Trt_1, Trl_3, Toprl_3, Trl_4, Toprl_4, Toprt_1, Trt_2, Toprt_2, Trt_3, Toprt_3, Trt_4, Toprt_4;
    //1 - ЛПС, 2-ТПС
    Tr_T_opr(Trl_1, Toprl_1, 1, T_1, M_1, k, T_ct);
    Tr_T_opr(Trl_2, Toprl_2, 1, T_2, M_2, k, T_ct);
    Trl_3 = 0; Toprl_3 = 0; Trl_4 = 0; Toprl_4 = 0;
    Tr_T_opr(Trt_1, Toprt_1, 0, T_1, M_1, k, T_ct);
    Tr_T_opr(Trt_2, Toprt_2, 0, T_2, M_2, k, T_ct);
    Tr_T_opr(Trt_3, Toprt_3, 0, T_3, M_3, k, T_ct);
    Tr_T_opr(Trt_4, Toprt_4, 0, T_4, M_4, k, T_ct);
    
    cout << "\n\nТемпература восстановления на гранях: \nTr_lam_1 = " << Trl_1 << "\nTr_lam_2 = " << Trl_2 << "\nTr_lam_3 = " << Trl_3 << "\nTr_lam_4 = " << Trl_4; 
    cout << "\nTr_turb_1 = " << Trt_1 << "\nTr_turb_2 = " << Trt_2 << "\nTr_turb_3 = " << Trt_3 << "\nTr_turb_4 = " << Trt_4;
    cout << "\n\nОпределяющая температура на гранях: \nToprl_1 = " << Toprl_1 << "\nToprl_2 = " << Toprl_2 << "\nTopr_lam_3 = " << Toprl_3 << "\nTopr_lam_4 = " << Toprl_4;
    cout << "\nToprt_1 = " << Toprt_1 << "\nToprt_2 = " << Toprt_2 << "\nToprt_3 = " << Toprt_3 << "\nToprt_4 = " << Toprt_4;
    

    // Критическое число Рейнольдса для 1 и 2 грани
    double Re_kr1, Re_kr2;
    Rekr(Re_kr1, T_ct, Trl_1, M_1, Re_kp);
    Rekr(Re_kr2, T_ct, Trl_2, M_2, Re_kp);
    cout << "\n\nКритическое число Рейнольдса :\nRe_kr1 = " << Re_kr1 << "\nRe_kr2 = " << Re_kr2;

    //  Координаты точек перехода
    double xkr1, xkr2;
    xkr1 = Re_kr1 * mu_1 / (v_1 * ro_1);
    xkr2 = Re_kr2 * mu_2 / (v_2 * ro_2);
    cout << "\n\nКоординаты точек перехода :\nxkr1 = " << xkr1 << "\nxkr2 = " << xkr2;
    
    // Характерные точки для 1 и 3 граней
    double L = b / (2 * cos(beta)); //Длина грани
    cout << "\n\nДлина грани " << L;
    // Создаем массив с 18 элементами
    double x[18];
    //Грань 1
    x[0] = xkr1 / 2;
    x[1] = xkr1;
    x[2] = xkr1;
    x[3] = xkr1 + (L - xkr1) / 3;
    x[4] = L - (L - xkr1) / 3;
    x[5] = L;
    //Грань 3
    x[6] = 0;
    x[7] = L / 2;
    x[8] = L;
    //Грань 2
    x[9] = xkr2 / 2;
    x[10] = xkr2;
    x[11] = xkr2;
    x[12] = xkr2 + (L - xkr2);
    x[13] = L - (L - xkr2) / 3;
    x[14] = L;
    //Грань 4
    x[15] = 0;
    x[16] = L / 2;
    x[17] = L;

    cout << "\n\nКоординаты характерных точек:\n";
    for (int i = 1; i <= 18; ++i) {
        cout << "x[" << i << "] = " << x[i - 1] << endl;
    }

    double x1f = x[0]; 
    double x2f = x[1];
    double x10f = x[9];
    double x11f = x[10];
    cout << "x1f = " << x1f << "\nx2f = " << x2f << "\nx10f = " << x10f << "\nx11f = " << x11f;



    // ===================== Пункт 8: расчет параметров пограничного слоя (табл. 8) =====================
    const double ndin = 0.76; // показатель степени для μ(T) из (35)

    // Для расчета ПС используем метры (L и координаты x)
    const double L_m = (b / (2.0 * cos(beta))) / 1000.0; // L в метрах (b задано в мм)
    cout << "\n\n[Пункт 8] Длина грани для ПС (м): L = " << L_m;

    // 1) Находим δл в критическом сечении и Δx (формула на стр. 15 PDF)
    const double delta_l_kr1 = (4.64 * xkr1) / sqrt(Re_kr1) * pow((Toprl_1 / T_1), 0.5 * (ndin + 1.0));
    const double delta_l_kr2 = (4.64 * xkr2) / sqrt(Re_kr2) * pow((Toprl_2 / T_2), 0.5 * (ndin + 1.0));

    const double deltaX1 = DeltaX_from_deltaLam(delta_l_kr1, v_1, ro_1, mu_1, Toprt_1, T_1, ndin);
    const double deltaX2 = DeltaX_from_deltaLam(delta_l_kr2, v_2, ro_2, mu_2, Toprt_2, T_2, ndin);

    cout << "\nΔx1 = " << deltaX1 << " м";
    cout << "\nΔx2 = " << deltaX2 << " м";

    // Дополнительный вывод Δx в формате, как в методичке (Δx, 10^-2 м)
    {
        ios::fmtflags oldFlags = cout.flags();
        streamsize oldPrec = cout.precision();

        cout << "\n\nОпределение Δx по формуле (Δx, 10^-2 м):\n";
        cout << fixed << setprecision(2);
        cout << "Δx1 = " << (deltaX1 * 1e2) << "\n";
        cout << "Δx2 = " << (deltaX2 * 1e2) << "\n";

        cout.flags(oldFlags);
        cout.precision(oldPrec);
    }

    // 2) Толщина δ в конце граней 1 и 2 (для перехода на грань 3 и 4 соответственно)
    double Re_tmp, dlt_tmp, tau_tmp, cfx_tmp, cf_tmp, dltst_tmp, dltsq_tmp;
    double DLT_tmp, TAU_tmp, CFX_tmp, CF_tmp, DLTst_tmp, DLTsq_tmp;

    // конец грани 1: x = L_m, xf = (L_m - xkr1 + Δx1)
    const double xf_end1 = (L_m - xkr1) + deltaX1;
    TurNes(Re_tmp, dlt_tmp, tau_tmp, cfx_tmp, cf_tmp, dltst_tmp, dltsq_tmp, v_1, ro_1, xf_end1, mu_1);
    TurS(DLT_tmp, TAU_tmp, CFX_tmp, CF_tmp, DLTst_tmp, DLTsq_tmp, dlt_tmp, tau_tmp, cfx_tmp, cf_tmp,
         dltst_tmp, dltsq_tmp, Toprt_1, T_1, ndin);
    const double delta_end1 = DLT_tmp;

    // конец грани 2: x = L_m, xf = (L_m - xkr2 + Δx2)
    const double xf_end2 = (L_m - xkr2) + deltaX2;
    TurNes(Re_tmp, dlt_tmp, tau_tmp, cfx_tmp, cf_tmp, dltst_tmp, dltsq_tmp, v_2, ro_2, xf_end2, mu_2);
    TurS(DLT_tmp, TAU_tmp, CFX_tmp, CF_tmp, DLTst_tmp, DLTsq_tmp, dlt_tmp, tau_tmp, cfx_tmp, cf_tmp,
         dltst_tmp, dltsq_tmp, Toprt_2, T_2, ndin);
    const double delta_end2 = DLT_tmp;

    // 3) Фиктивные длины для граней 3 и 4: xf0 так, чтобы δ(xf0) = δ(конец предыдущей грани)
    const double xf3_0 = Xf_from_deltaTurb(delta_end1, v_3, ro_3, mu_3, Toprt_3, T_3, ndin);
    const double xf4_0 = Xf_from_deltaTurb(delta_end2, v_4, ro_4, mu_4, Toprt_4, T_4, ndin);

    cout << "\nxf3_0 = " << xf3_0 << " м (фиктивная пластина перед гранью 3)";
    cout << "\nxf4_0 = " << xf4_0 << " м (фиктивная пластина перед гранью 4)\n";

    // 4) Собираем точки табл. 8 (1–18) и считаем параметры ПС
    BLRow rows[18];

    auto fillLam = [&](BLRow& r, double V, double rho, double mu, double Tstarl, double Tedge) {
        LamNes(r.Re_ns, r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, r.delta_star_ns, r.delta_sqr_ns, V, rho, r.xf, mu);
        LamS(r.delta, r.tau, r.cfx, r.cf, r.delta_star, r.delta_sqr,
             r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, r.delta_star_ns, r.delta_sqr_ns,
             Tstarl, Tedge, ndin);
    };

    auto fillTur = [&](BLRow& r, double V, double rho, double mu, double Tstart, double Tedge) {
        TurNes(r.Re_ns, r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, r.delta_star_ns, r.delta_sqr_ns, V, rho, r.xf, mu);
        TurS(r.delta, r.tau, r.cfx, r.cf, r.delta_star, r.delta_sqr,
             r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, r.delta_star_ns, r.delta_sqr_ns,
             Tstart, Tedge, ndin);
    };

    auto fillTurWithOffsetCf = [&](BLRow& r, double V, double rho, double mu, double Tstart, double Tedge, double offset) {
        double cf1 = 0.0, Re1 = 0.0;
        TurNes8_9_17_18(r.Re_ns, r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, cf1, r.delta_star_ns, r.delta_sqr_ns,
                        V, rho, r.xf, mu, offset, Re1);

        // Cf в таблице нужен средний по длине рассматриваемого участка (от x=0 до текущей точки).
        double Cf_it = 0.0;
        TurS8_9_17_18(r.delta, r.tau, r.cfx, Cf_it, r.delta_star, r.delta_sqr,
                      r.delta_ns, r.tau_ns, r.cfx_ns, r.cf_ns, cf1,
                      r.delta_star_ns, r.delta_sqr_ns, Tstart, Tedge, ndin, offset, r.xf);
        r.cf = Cf_it;
    };

    int idxRow = 0;

    // --- Грань 1: точки 1–6 ---
    {
        // 1) x = xкр/2
        rows[idxRow] = {1, 1, xkr1 / 2.0, xkr1 / 2.0};
        fillLam(rows[idxRow], v_1, ro_1, mu_1, Toprl_1, T_1); idxRow++;

        // 2) x = xкр
        rows[idxRow] = {1, 2, xkr1, xkr1};
        fillLam(rows[idxRow], v_1, ro_1, mu_1, Toprl_1, T_1); idxRow++;

        // 3) x = xкр, xf = Δx
        rows[idxRow] = {1, 3, xkr1, deltaX1};
        fillTur(rows[idxRow], v_1, ro_1, mu_1, Toprt_1, T_1); idxRow++;

        // 4–6) турбулентная часть: xf = (x - xкр + Δx)
        const double x4 = xkr1 + (L_m - xkr1) / 3.0;
        const double x5 = L_m - (L_m - xkr1) / 3.0;
        const double x6 = L_m;

        rows[idxRow] = {1, 4, x4, (x4 - xkr1) + deltaX1};
        fillTur(rows[idxRow], v_1, ro_1, mu_1, Toprt_1, T_1); idxRow++;

        rows[idxRow] = {1, 5, x5, (x5 - xkr1) + deltaX1};
        fillTur(rows[idxRow], v_1, ro_1, mu_1, Toprt_1, T_1); idxRow++;

        rows[idxRow] = {1, 6, x6, (x6 - xkr1) + deltaX1};
        fillTur(rows[idxRow], v_1, ro_1, mu_1, Toprt_1, T_1); idxRow++;
    }

    // --- Грань 3: точки 7–9 (турбулентный ПС, стартовая толщина = как в конце грани 1) ---
    {
        rows[idxRow] = {3, 7, 0.0, xf3_0};
        fillTur(rows[idxRow], v_3, ro_3, mu_3, Toprt_3, T_3);
        rows[idxRow].cf = 0.0; // средний Cf на участке нулевой длины
        idxRow++;

        rows[idxRow] = {3, 8, L_m / 2.0, xf3_0 + L_m / 2.0};
        fillTurWithOffsetCf(rows[idxRow], v_3, ro_3, mu_3, Toprt_3, T_3, xf3_0);
        idxRow++;

        rows[idxRow] = {3, 9, L_m, xf3_0 + L_m};
        fillTurWithOffsetCf(rows[idxRow], v_3, ro_3, mu_3, Toprt_3, T_3, xf3_0);
        idxRow++;
    }

    // --- Грань 2: точки 10–15 ---
    {
        rows[idxRow] = {2, 10, xkr2 / 2.0, xkr2 / 2.0};
        fillLam(rows[idxRow], v_2, ro_2, mu_2, Toprl_2, T_2); idxRow++;

        rows[idxRow] = {2, 11, xkr2, xkr2};
        fillLam(rows[idxRow], v_2, ro_2, mu_2, Toprl_2, T_2); idxRow++;

        rows[idxRow] = {2, 12, xkr2, deltaX2};
        fillTur(rows[idxRow], v_2, ro_2, mu_2, Toprt_2, T_2); idxRow++;

        const double x13 = xkr2 + (L_m - xkr2) / 3.0;
        const double x14 = L_m - (L_m - xkr2) / 3.0;
        const double x15 = L_m;

        rows[idxRow] = {2, 13, x13, (x13 - xkr2) + deltaX2};
        fillTur(rows[idxRow], v_2, ro_2, mu_2, Toprt_2, T_2); idxRow++;

        rows[idxRow] = {2, 14, x14, (x14 - xkr2) + deltaX2};
        fillTur(rows[idxRow], v_2, ro_2, mu_2, Toprt_2, T_2); idxRow++;

        rows[idxRow] = {2, 15, x15, (x15 - xkr2) + deltaX2};
        fillTur(rows[idxRow], v_2, ro_2, mu_2, Toprt_2, T_2); idxRow++;
    }

    // --- Грань 4: точки 16–18 (турбулентный ПС, стартовая толщина = как в конце грани 2) ---
    {
        rows[idxRow] = {4, 16, 0.0, xf4_0};
        fillTur(rows[idxRow], v_4, ro_4, mu_4, Toprt_4, T_4);
        rows[idxRow].cf = 0.0;
        idxRow++;

        rows[idxRow] = {4, 17, L_m / 2.0, xf4_0 + L_m / 2.0};
        fillTurWithOffsetCf(rows[idxRow], v_4, ro_4, mu_4, Toprt_4, T_4, xf4_0);
        idxRow++;

        rows[idxRow] = {4, 18, L_m, xf4_0 + L_m};
        fillTurWithOffsetCf(rows[idxRow], v_4, ro_4, mu_4, Toprt_4, T_4, xf4_0);
        idxRow++;
    }

    PrintBLHeader();
    for (int i = 0; i < 18; ++i) PrintBLRow(rows[i]);


    // ===================== Пункт 9: вывод сил трения по граням =====================
    // (коэффициенты трения в программе уже посчитаны; здесь добавлен только вывод сил)
    {
        // Средние коэффициенты трения по граням (Cfср) в сжимаемом ПС

        // --- Грань 1: смешанный ПС (ламинарный + турбулентный) ---
        const double Cf_lam_1 = rows[1].cf;   // точка 2: средний Cf на участке 0..xкр1 (ламинарный)
        const double Cf_t1_1  = rows[5].cf;   // точка 6: средний Cf на участке 0..(L-xкр1+Δx1) (турбулентный)
        const double Cf_t2_1  = rows[2].cf;   // точка 3: средний Cf на участке 0..Δx1 (турбулентный)
        const double l1 = xf_end1;            // (L - xкр1 + Δx1)
        const double Cf_face1 = Cf_lam_1 * (xkr1 / L_m) + Cf_t1_1 * (l1 / L_m) - Cf_t2_1 * (deltaX1 / L_m);

        // --- Грань 2: смешанный ПС (ламинарный + турбулентный) ---
        const double Cf_lam_2 = rows[10].cf;  // точка 11: средний Cf на участке 0..xкр2 (ламинарный)
        const double Cf_t1_2  = rows[14].cf;  // точка 15: средний Cf на участке 0..(L-xкр2+Δx2) (турбулентный)
        const double Cf_t2_2  = rows[11].cf;  // точка 12: средний Cf на участке 0..Δx2 (турбулентный)
        const double l2 = xf_end2;            // (L - xкр2 + Δx2)
        const double Cf_face2 = Cf_lam_2 * (xkr2 / L_m) + Cf_t1_2 * (l2 / L_m) - Cf_t2_2 * (deltaX2 / L_m);

        // --- Грани 3 и 4: турбулентный ПС с фиктивной длиной ---
        const double Cf_face3 = rows[8].cf;   // точка 9: средний Cf по длине грани 3
        const double Cf_face4 = rows[17].cf;  // точка 18: средний Cf по длине грани 4

        // Скоростные напоры по граням
        const double q1 = 0.5 * ro_1 * v_1 * v_1;
        const double q2 = 0.5 * ro_2 * v_2 * v_2;
        const double q3 = 0.5 * ro_3 * v_3 * v_3;
        const double q4 = 0.5 * ro_4 * v_4 * v_4;

        // Силы трения по граням (Н при единичном размахе), формула (56): Fтр_i = Cfср_i * q_i * L
        const double Ftr1 = Cf_face1 * q1 * L_m;
        const double Ftr2 = Cf_face2 * q2 * L_m;
        const double Ftr3 = Cf_face3 * q3 * L_m;
        const double Ftr4 = Cf_face4 * q4 * L_m;

        cout << "\n\n9. Определение поправки на трение";
        cout << "\nТабл. 8. Средние коэффициенты трения по граням:";
        cout << "\nCfср1 = " << Cf_face1 * 1e3 << " *10^-3";
        cout << "\nCfср2 = " << Cf_face2 * 1e3 << " *10^-3";
        cout << "\nCfср3 = " << Cf_face3 * 1e3 << " *10^-3";
        cout << "\nCfср4 = " << Cf_face4 * 1e3 << " *10^-3";

        cout << "\n\nСилы трения по граням (Н при единичном размахе):";
        cout << "\nFтр1 = " << Ftr1;
        cout << "\nFтр2 = " << Ftr2;
        cout << "\nFтр3 = " << Ftr3;
        cout << "\nFтр4 = " << Ftr4;

        // При необходимости: суммарная продольная составляющая трения (57)
        const double Xtr = (Ftr1 + Ftr2 + Ftr3 + Ftr4) * cos(beta);
        cout << "\n\nXтр = " << Xtr;
    }


}
